+++
date = '2024-12-21T13:49:00+08:00'
draft = true
title = '数值计算方法(2) 数值积分方法'
+++

上一期讲了插值方法，这一次自然是要运用一下插值方法了。所以这一期的主题是用插值方法计算定积分。

### 机械求积方法

下面我们来介绍一下怎么用插值法来得到数值方法计算函数积分。

对于大部分函数，我们其实都是很难求其积分的，甚至很多函数例如$e^{x^2}$这样的函数压根就没有初等原函数。所以我们需要寻找数值方法来计算他们的积分。

对于大多数函数，我们不仅很难求积分，也许微分也很难求，所以我们希望的数值方法一定是不能包含这俩的。

为了简化问题，我们最终的求积公式就用函数值的线性组合试试看了。

这种最简单的求积公式就是机械求积。

也就是找到某些点的函数值，用这些点的函数值的某个线性组合来近似积分值。

即机械求积公式认为$\int_a^b f(x)dx \approx \sum_{k=0}^n A_k y_k$

所以关键点就是点的选取和组合系数$$A_k$$的选择了。

一种可能的思路就是用上一期提的插值多项式来近似替代这个函数。而且我们是已知了差值余项的，余项的积分就是我们数值积分方法的误差。

而这些都是多项式啊，都很好计算的。

这种求积分的数值方法得到的积分公式我们都叫做**差值型的求积公式**。

而在插值方法里，点的选择是任意的，那我们就暂且也让大家任意选择。

这样只需要知道组合系数$A_k$就知道怎么求积了。

而对于插值型求积公式，我们很容易就能得到$A_k$。

插值型求积公式就是用f(x)的插值多项式近似f(x)，从而有

$\int_a^bf(x)dx \approx \int_a^bp_n(x)dx$

再把拉格朗日插值公式代入得

$\int_a^bf(x)dx \approx \int_a^b \sum_{k=1}^n y_k l_k(x)dx$

$=\sum_{k=1}^n y_k\int_a^bl_k(x)dx$

而我们的机械求积公式是$\int_a^b f(x)dx=\sum_{k=0}^n A_k y_k$，从而

$A_k=\int_a^b l_k(x)dx$

### 代数精度

你也许会觉得这个办法非常粗糙，确实！我们可以来分析一下他的精度。余项么，自然就是拉格朗日插值余项的积分了，这个没啥好说的。

我们在机械求积里其实最关注代数精度了。

我们拿多项式函数来表彰一个求积公式的精度。

取多项式$$p(x)=a_nx^n+a_{n-1}x^{n-1}+...+a_0$$

由于多项式函数总是很容易求出积分的准确值的。

我们就来看看你的求积公式是从几次多项式开始才变得不准确的。这个次数就是求积公式的代数精度。

事实上，我们前面那种求积方式的代数精度是很容易看出来的。

你用n次多项式插值f(x)而我们代入验证的f(x)是m次多项式。

如果n=m，那么你的插值多项式就是我们代入验证的m次多项式。

如果n比m还大呢？求积公式的插值多项式会退化为m次多项式，所以积分自然也还是准确的。

因此，n次插值多项式得到的求积公式至少具有n次代数精度。

我这里是用的任意n次多项式来进行验证，不过你在外面看到的定义可能是说用$$x^n$$代入验证，事实上我们俩说的是等价的。

其他人的说法是你代入$$1,x,x^2,...,x^n$$，一直到$$x^{n-1}$$次方，你都发现求积公式是准确的，但n次方开始不准确了，这时说求积公式有n-1次代数精度。

显然，他们的定义是我说的定义的特殊情况，所以满足我的定义的，自然满足他们的定义。

而满足他们定义的求积公式，对$$x^{n-1}$$都准确。

则我取任意的n-1次多项式，$$p(x)=a_{n-1}x^{n-1}+...+a_0$$

求积分$$\int_a^bp(x)dx=a_{n-1}\int_a^bx^{n-1}dx+a_{n-2}\int_a^bx^{n-2}dx+...+a_0\int_a^b1dx$$

$$1,x,x^2,...,x^{n-1}$$的积分准确，那么p(x)的积分也就是准确的了。

所以我们俩的代数精度的定义是等价的，只不过我这个看起来要强一些而已。

### 牛顿-科特斯公式

前面我们给的机械求积公式略显粗糙，但也能取得至少n次代数精度，接下来我们会对求积公式进行加强，对它有更高的要求。

组合系数$$A_k$$是死的了，所以下面的加强都是从插值点入手。

例如牛顿-科特斯公式就是进一步要求，插值点的间距相等（步长为h），然后得到一个特殊的结论。

我们竟然将区间长度提出来了，

$\int_a^b f(x)dx=(b-a)\sum_{k=0}^n C_k f(x_k)$

并且，$C_k$竟然还是常数。

我们称$C_k$为科特斯系数，可以直接查科特斯系数表得到，与具体的函数f(x)无关，只和你插值多项式的次数n有关!

这就是牛顿-科特斯公式。

![科特斯系数表](https://pic4.zhimg.com/v2-16ffe2d3526f06ffdd0eb18c7b76150f_r.jpg)

其中n=1得到的求积公式被称为**梯形公式**，n=2的是**辛普森公式**。

一般我们也就只用到辛普森公式为止，这是因为前面我们说过插值多项式有龙格现象，也就是会过拟合。我们这里也是一样，你用的求积公式次数太高，插值多项式在区间端点附近疯狂震荡，而且这时候你稍微变一下计算用的数值最后的计算结果差距会非常大（这种情况我们称为**数值稳定性**差）。

所以记住常用的求积公式，三个矩形公式，也就是

左矩形公式：把f(x)直接当做常函数f(a)求矩形的面积$$\int_a^bf(x)dx=(b-a)f(a)$$

还有右矩形公式：$$\int_a^bf(x)dx=(b-a)f(b)$$

以及中矩形公式：$$\int_a^bf(x)dx=(b-a)f(\frac{a+b}{2})$$

梯形公式，把f(x)看作(a,f(a)),(b,f(b))的直线求梯形面积,当然也是什么的n=1时的牛顿科特斯公式$$\int_a^bf(x)dx=(b-a)\frac{1*f(b)+1*f(a)}{1+1}$$

既然梯形公式是把f(x)看作(a,f(a)),(b,f(b))的直线求梯形面积你其实大可不必用上面我写的复杂的式子，直接上底+下底再乘高除2就完事了。

我也这样是为了让你记住辛普森公式。

辛普森公式涉及三个点，然后是等距的，这里假定求a,c的积分，b就是a和c的中点，从而

$$\int_a^cf(x)dx=(c-a)\frac{1*f(a)+4*f(b)+1*f(c)}{1+4+1}$$

重点在系数1,4,1，记住这个就可以了。

这也是上面的牛顿-科特斯系数表不把$$\frac{4}{6}$$化简的原因。

这里也点出了牛顿-科特斯系数表的性质即每一行的和为1。

好了，总之这样你应该就记住了这几个公式了。

但是问题来了，这玩意儿啊都是用的低阶插值，所以代数精度不也就低了。

左右矩形公式只用了1个点，所以是0阶插值的结果，有0阶代数精度。

梯形公式两个点，是线性插值的结果，只有1阶代数精度。

辛普森公式3个点，是抛物插值的结果，2阶代数精度，这不就完全垮了啊！

你应该能想到应该怎么做，分段呗，继续分段。

### 复化方法

这种分段的方法在前面分段低次插值和样条插值里你已经见过了，只不过在这里叫复化方法。

对应的求积公式叫**复化求积公式**。

我们将区间[a,b]n等分，然后用低阶求积公式求每一段的积分值，然后累加就是整个区间的积分值了，复化方法就是这么简单。

但是我一写公式你又头晕了。

记住上面那一句话的本质即可，公式你对照着本质看就能看懂了。

我们将[a,b]按步长h等分成n份，分点就是$$x_k=a+kh,k=0,1,2,...,n$$，没毛病吧。区间有n个，所以要n+1个分点，这里下标从0开始，所以k最多取n。

然后求出这n段的积分$$I_k$$，注意，分点是0到n，有n+1个分点，区间有n个，如果下标还是从0开始那么k最多到n-1。

然后将这n个积分求和就是$$\int_a^b f(x)dx=\sum_{k=0}^{n-1}I_k$$。

到这里是最一般的复化求积公式，没错哈。

然后我们再用低阶求积公式求具体的$$I_k$$。

例如，用梯形公式求区间$$[x_k,x_{k+1}]$$的积分。注意哈k从0开始，而$$x_0=a$$，而这边是$$[a,a+h],[a+h,a+2h]$$这样分区间的，所以区间是k到k+1。

好，来用梯形公式得到$$I_k=h*\frac{f(x_k)+f(x_{k+1})}{2}$$

再试试用辛普森公式求解，$$I_k=h*\frac{f(x_k)+4*f(x_{k+\frac{1}{2}})+f(x_{k+1})}{6}$$

这里$$x_{k+\frac{1}{2}}$$指的是$$x_k$$和$$x_{k+1}$$的中点。

接下来要把$$I_k$$代入复化求积公式了哈。

这样就得到复化梯形公式$$\int_a^b f(x)dx=\sum_{k=0}^{n-1}h*\frac{f(x_k)+f(x_{k+1})}{2}$$

复化辛普森公式$$\int_a^b f(x)dx=\sum_{k=0}^{n-1}h*\frac{f(x_k)+4*f(x_{k+\frac{1}{2}})+f(x_{k+1})}{6}$$

不过你在外面看到的式子可能不是这样的，我们来化简一下。

首先把常数提出去。

复化梯形公式$$\int_a^b f(x)dx=\frac{h}{2}\sum_{k=0}^{n-1}f(x_k)+f(x_{k+1})$$

复化辛普森公式$$\int_a^b f(x)dx=\frac{h}{6}\sum_{k=0}^{n-1}f(x_k)+4*f(x_{k+\frac{1}{2}})+f(x_{k+1})$$

接下来，注意一下哈，$$x_k,x_{k+1}$$都是区间的分点，所以我在累加的时候除了两端的分点只加了一次，其他分点都加了两次，而$$f(x_{k+\frac{1}{2}})$$是区间分点的中点也只加了一次。

所以式子可以再化简一下这样就是常见的两个复化求积公式了。

复化梯形公式$$\int_a^b f(x)dx=\frac{h}{2}[f(a)+2\sum_{k=1}^{n-1}f(x_k)+f(b)]$$

复化辛普森公式$$\int_a^b f(x)dx=\frac{h}{6}[f(a)+2\sum_{k=1}^{n-1}f(x_k)+\sum_{k=0}^{n-1}4*f(x_{k+\frac{1}{2}})+f(b)]$$

再来解析一下，f(a)和f(b)是区间的端点，只加了一次，所以系数是1，而$$f(x_{k+\frac{1}{2}})$$是区间分点的中点也只加了一次，所以系数也不变。

式子里的$$2\sum_{k=1}^{n-1}f(x_k)$$是区间的内分点，都加了两次所以前面系数带了2。

总之，复化方法就是这样。但是复化方法有一个不好的地方，就是他的步长h依然是我们随便选取的，我们能不能让他自己找到一个合适的步长h？

### 龙贝格算法

这就是龙贝格算法了。

龙贝格算法其实也是一种事后估计方法。

我们先来计算一下误差，有误差才能事后估计嘛。

从简单的梯形公式开始。

按照拉格朗日插值余项，梯形公式的误差$$I-T_n=\sum_{k=0}^{n-1}-\frac{h^3f''(\alpha_k)}{12}$$

而这里为了消掉中值，我们认为h很小，从而$$hf''(\alpha_k) \approx f'(x_{k+1})-f'(x_k)$$

也因此梯形公式的误差$$I-T_n=\sum_{k=0}^{n-1}-\frac{h^3f''(\alpha_k)}{12}\approx \frac{-h^2}{12} [f'(b)-f'(a)]$$

这个误差和$h^2$是一个数量级的。

类似地，可以推出辛普森公式$$S_n$$的误差和$$h^4$$一个数量级，而在牛顿-科特斯公式里n=3的时候得到的三次插值公式对应的求积公式我们称为科特斯公式是$$h^6$$数量级的。（科特斯公式前面没让你用，但是这里确实需要了，你想记的话也可以回去记啦）

基于此我们进行误差事后估计。

对了，在这里$$T_n,S_n,C_n$$的角标n指的是复化公式里区间的段的数量。

我们这里说要变步长其实就是变区间的段数嘛。

复化梯形公式误差和$h^2$是一个数量级的，所以步长变为原来的一半也就是区间分段分为原来的2倍，则误差大概变成了原来的四分之一。

所以$$\frac{I-T_{2n}}{I-T_n}\approx\frac{1}{4}$$

熟悉的式子。

我们又可以得到更精确的$$T_{2n}$$的估计值$$I=\frac{4}{3}T_{2n}-\frac{1}{3}T_n$$了。

不过这里我要把式子写成

$$S_n=\frac{4^1}{4^1-1}T_{2n}-\frac{1}{4^1-1}T_n$$

没错，熟悉的结果，对复化梯形公式进行事后估计得到了复化辛普森公式。

接下来你应该都猜得到结果了。

$$C_n=\frac{4^2}{4^2-1}S_{2n}-\frac{1}{4^2-1}S_n$$

$$R_n=\frac{4^3}{4^3-1}C_{2n}-\frac{1}{4^3-1}C_n$$

额，这里$$R_n$$是复化龙贝格公式啦。

总之，现在按这样的方法进行加工，就可以逐步提高求积精度，这就是龙贝格算法。

![龙贝格算法图](https://pic3.zhimg.com/v2-b6d161080eeaf6f53dc39e79306d2800_r.jpg)

你应该也能想到我要掏出这样的图了。

现在这样步长h是可以随着计算折半的，其实我也觉得到这里就很完美了。

### 高斯求积公式

谁知道高斯求积公式出现了。

高斯求积公式彻底解决了插值点的选取问题，用这个方法选取的一定是最优插值点，而且代数精度是最高的。

选取适当的$$x_0,x_1,...,x_n$$这n+1个点，高斯求积公式可以达到至少2n+1的代数精度。

这里选择的这些插值点被称为高斯点。

如果选取了n个高斯点得到的高斯公式称为n点高斯公式。（注意我前面说的是n+1个点有2n+1阶代数精度，那n个点就有2n-1阶代数精度）

1点高斯公式就是中矩形公式。

我们来试着求求看两点公式高斯。

注意，在高斯公式里，我们只能求[-1,1]的积分。

如果你想求解[a,b]的积分，可以先换元。

做一个简单的变换，令$$x=\frac{b-a}{2}t+\frac{a+b}{2}$$，就可以把积分区间变成[-1,1]了。

现在想求两点高斯公式就是要找组合系数$$A_1,A_2$$和合适的分点$$x_1,x_2$$使得

$$\int_{-1}^1f(x)dx=A_1f(x_1)+A_2f(x_2)$$

并且两点高斯公式具有2*2-1阶代数精度，所以他对$$1,x,x^2,x^3$$都精确成立。

这样你会得到一个四元三次方程组，根本求解不来啊亲。

还好，有数学家已经“注意到”高斯点的求解了。

n点高斯公式的n个高斯点，就是n次**勒让德多项式**的零点。

所以真正实用的求积方法是，想用n点高斯公式先写出n次勒让德多项式，再求出其零点，然后零点就是求积点。现在已知了求积节点，不就回到了最开始的机械求积方法了？用那里的方法求出$$A_k$$就可以了。

那么勒让德多项式怎么来的？

其实考虑这个问题之前，你大概连勒让德多项式都没听说过吧。

我们这里指的勒让德多项式就是百度百科里的定义二。

![勒让德多项式.png](https://527a87a9.cloudflare-imgbed-bo7.pages.dev/file/1734766821752_勒让德多项式.png)

这式子超恐怖，但是其实你不用了解，这是因为我们前面已经说过了，插值型求积公式的插值次数不能太高，太高了精度反而下降了。

所以我们一样要进行复化，也可以用龙贝格算法进行加速。

这样的话其实我们只涉及到低次勒让德多项式，你真的想用的话网上搜一下不就知道了啊哈哈。

