+++
date = '2024-12-21T15:45:47+08:00'
draft = true
title = '数值计算方法(3) 数值微分方法'
+++

上一期讲了数值积分方法，这一次自然是要讲数值微分方法的，不然太不完善了。

更何况数值微分方法其实是基于数值积分方法得到的。

我们先从比较简单的估计导数值来开篇。

### 差商方法

估计函数的导数值意义其实没有前面积分那么大，因为基本初等函数都能很容易地求导，有准确值了近似值的意义就没有那么大了。

不过还是来试试吧。

近似导数的最简单的方法就是用导数的定义。

你看一阶差商$\frac{f(a+h)-f(a)}{h}$，当h趋于0时根据这就是导数的定义啊，所以反过来我们可以让h非常小，这样就是导数的近似值了。

这种差商在这里有一个名字叫向前差商。

有向前自然就有向后$\frac{f(a)-f(a-h)}{h}$。

其实还有中心差商$\frac{f(a+h)-f(a-h)}{2h}$。

中心差商还有一个名字叫中点方法，其实这玩意也能看做是向前差商和向后差商的平均值。

如果是我们手算的话，其实这样就很好了。

我们手算的话h越小误差越小，但这么麻烦的东西自然是不可能手算的。

但是一旦交给计算机算啊，h如果太小，计算机计算的误差就会增加（计算机进行浮点数运算是不准确的，这是由浮点数的存储方式决定的，计算机的浮点数大多都按照IEEE的规范设计的，是存在舍入误差的）。

总之，现在这个h如果太大，从数学上看的误差会变大（我们称为截断误差），h如果太小计算机计算的时候舍入误差会太大。

那么又来了，步长h应该怎么选呢？

这情况和龙贝格算法一模一样啊。

你猜怎么着，结果也一样。还是用类似的加速方法，还是进行误差的事后估计，并且也还是将步长折半。

我们可以导出一个一模一样的加速公式。

$G_n(h)=\frac{4^nG_{n-1}(\frac{h}{2})-G_{n-1}(h)}{4^n-1}$

然后画一模一样的表就可以了。

### 插值型求导公式

前面我们说插值是对函数的拟合，所以这里自然可以用插值多项式替代函数f(x)，用插值多项式的导数作为f(x)导数的近似，但是这玩意儿没那么靠谱，因为插值多项式在函数值上比较接近，但是他们的导数值可能差得很远，所以这条路子没那么靠谱，也就没那么多理论了。你就当是半破产了吧。而且操作起来也不难，就是无脑用插值多项式替代f(x)而已，所以不多说了。

接下来才是重点，唠唠怎么求解微分方程。

### 微分方程数值解

微分方程数值解的求法主要是利用了数值求积方法，在此我们以标准的微分方程初值问题为例介绍几个方法。

在《常微分方程》这门课程中（注意是一门课，不是高等数学的那个章节），你应该听过皮卡逐步逼近定理。

![皮卡逐步逼近定理.png](https://527a87a9.cloudflare-imgbed-bo7.pages.dev/file/1734768822752_皮卡逐步逼近定理.png)

它这里的微分方程近似解是一个多项式，而我们这里说的微分方程数值解不是这样的东西。

针对这样的初值问题，你给我一个步长h，我求出微分方程的解g(x)在x+h，x+2h,...等处的函数值，我们这里说的数值解是这样的东西。

当然，为了保证初值问题有且只有唯一的解，我们仍然要求f(x,y)关于y满足利普希茨条件。（没听过不用管，这是因为你没上过《常微分方程》这门课，总之就是要保证解存在且唯一而已，这个条件后文不会使用）

好接下来开始推导。

对微分方程

$\frac{dy}{dx}=f(x,y)$

我们两边同时积分得到

$\int_{x_n}^{x_{n+1}}\frac{dy}{dx}=\int_{x_n}^{x_{n+1}}f(x,y)dx$

也就是

$y_{n+1}-y_n=\int_{x_n}^{x_{n+1}}f(x,y)dx$

从而

$y_{n+1}=y_n+\int_{x_n}^{x_{n+1}}f(x,y)dx$

而如果我们可以用数值方法求出这个积分，不就解出了这个微分方程？

例如，我们直接用左矩形公式求积分，得到

$y_{n+1}=y_n+\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_n,y_n)$

这就是**欧拉格式**。(注意，数值微分里我们称为格式而不是公式，这里没有打错字)

你可能会发现我这里给的欧拉格式和网上一般的不一样，其实你只要设$h=x_{n+1}-x_n$（当我设了h就默认等步长了）就能得到一般的欧拉格式了。

$y_{n+1}=y_n+hf(x_n,y_n)$

同样地，我们可以用右矩形公式得到

$y_{n+1}=y_n+\int_{x_n}^{x_{n+1}}f(x,y)=y_n+(x_{n+1}-x_n)f(x_{n+1},y_{n+1})$

类似地，我们设$h=x_{n+1}-x_n$就有，

$y_{n+1}=y_n+hf(x_{n+1},y_{n+1})$

这就是**隐式欧拉格式**了。

那如果我用中矩形公式，还能得到两步欧拉格式：

对微分方程

$\frac{dy}{dx}=f(x,y)$

我们两边同时积分得到

$\int_{x_n-1}^{x_{n+1}}\frac{dy}{dx}=\int_{x_n-1}^{x_{n+1}}f(x,y)dx$

注意，这次是从$x_{n-1}$积到$x_n$，并且我们要求步长为h，则$x_n$是积分区间中点。

有$y_{n+1}-y_{n-1}=2hf(x_n,y_n)$

从而，$y_{n+1}=y_{n-1}+2hf(x_n,y_n)$

这就是**两步欧拉格式**。

还可以用梯形公式来求积分得到**梯形格式**。

$y_{n+1}=y_n+\int_{x_n}^{x_{n+1}}f(x,y)=y_n+\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y_{n+1})]$

注意力好的人应该已经发现了，梯形格式恰好是显式欧拉格式和隐式欧拉格式的算术平均。

### 预报-矫正系统与改进欧拉

前面扯了这么久感觉非常平淡啊，就是套用一下求积公式，下面来点有意思的。

你看梯形格式里是不是说需要$f(x_{n+1},y_{n+1})$？

你有没有想过这玩意儿哪里来？

是不是前面看得特爽但是这个最基本的东西没发现。

$f(x_{n+1},y_{n+1})$明明是下一次的东西，你怎么能让我现在就给出来呢？

其实是这样的，我们先用前面的一个显式格式预报一个$f(x_{n+1},y_{n+1})$出来，然后再用隐式格式得到一个矫正后的$y_{n+1}$，这样精度会更高。

例如，使用显式欧拉格式预报$y_{n+1}=y_n+hf(x_n,y_n )$

然后再把这个预报的$y_{n+1}$代入隐式欧拉，这就是改进欧拉格式了。

这样的一套系统我们称为预报-矫正系统。

你其实是可以任意组合的。

但是这样的方法仍然没有脱离求积公式的桎梏，而下面的方法就是重新开了一个方向了。

### 龙格-库塔方法

